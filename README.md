# Sprint_2 
___
## Задание 1
В этом задании нужно создать подвид тест-кейса.
Есть класс `Case`. Он содержит метод `print_test_case_info()`, который выводит на экран 
- id тест-кейса, 
- его название, 
- описание шага,
- ожидаемый результат. 
Что нужно сделать:
- Создать подкласс `ExtendedCase`. Он наследует все атрибуты из класса `Case`. Кроме того, нужно добавить ему два новых атрибута через конструктор — `precondition` и `environment`. Тип данных для них — строки.
- Переопределить метод `print_test_case_info()` в классе `ExtendedCase`. 
Он должен печатать:
- все атрибуты суперкласса;
- новые атрибуты подкласса в формате `"Предусловие: {precondition}"` и `Окружение: {environment}"`. Каждый атрибут нужно вывести с новой строки.
- Создай объект case класса ExtendedCase. 
- Входные параметры такие: `('1', 'Наличие кнопки Принять', '1. Открыть вкладку приёма документов 2. Проверить наличие кнопки ', 'Кнопка доступна', 'Открыть сервис', 'Яндекс Браузер')`.
Вызови метод print_test_case_info() для объекта casе.
```python
class Case:
    def __init__(self, test_case_id, name, step_description, expected_result):
        self.test_case_id = test_case_id
        self.name = name
        self.step_description = step_description
        self.expected_result = expected_result

    def print_test_case_info(self):
        print(f"ID тест-кейса:  {self.test_case_id}"
              f"\nНазвание: {self.name}"
              f"\nОписание шага: {self.step_description}"
              f"\nОжидаемый результат: {self.expected_result}")

... # напиши свой код здесь 
```
---
## Задание 2

- В этом задании нужно создать иерархию разных видов фильмов: драму и комедию, которые наследуются от суперкласса `Movies`.
- Создай класс `Movies`:
- проинициализируй в нём пустой список `self.movies` через конструктор;
- добавь метод `add_movie()`. Он будет принимать параметр `movie` и добавлять его в конец списка `self.movies`.
- Создай два дочерних класса — `Comedy` и `Drama`. Они наследуют метод `add_movie()`. Метод этих классов должен принимать параметр `movie` и добавлять его в конец списка `self.movies`. 
Затем возвращать записи вида Комедии: '[]' и Драмы: '[]' соответственно.
- Вызови метод `add_movie()` для объекта `Comedy()`. Входной параметр — `'Большой куш'`. Выведи на экран результат.
- Вызови метод `add_movie()` для объекта `Drama()`. Входной параметр — `'Оружейный барон'`. Выведи на экран результат.
---
## Задание 3

Нужно написать три класса для спортивных соревнований — разные способы начислять спортсменам очки:
1. PointsForPlace — количество очков равно месту, которое занял спортсмен.
2. PointsForMeters — количество очков высчитывается с учётом расстояния, на которое спортсмен метнул диск.
3. TotalPoints — умеет работать и с местом спортсмена, и с расстоянием.

Теперь подробно:

1. Нужно напиcать класс `PointsForPlace`. 
   - Он получает количество очков в зависимости от места, которое занял спортсмен.
   - В этом классе есть метод `get_points_for_place()`, который принимает аргумент `place` — целое число. Причём: 
   - Если место `строго больше 100`, должно выводиться сообщение `'Баллы начисляются только первым 100 участникам'`.
   - Если как аргумент передали значение `меньше 1`, должно печататься сообщение `'Спортсмен не может занять нулевое или отрицательное место'`.
   - В остальных случаях начисляются очки по формуле: 101 - place.
   - Изначально количество очков равно нулю.
   - Метод get_points_for_place() должен возвращать points.
2. Нужно создать класс `PointsForMeters`. 
   - Он рассчитывает очки в зависимости от количества метров, на которое спортсмен толкнул ядро или метнул диск: `расстояние*0,5`. Например, если расстояние 10 метров, спортсмен получит 5 очков.
   - Напиши метод `get_points_for_meters()`, который принимает аргумент `meters` — целое число. Причём:
     - Если количество метров `меньше нуля`, должно выводиться сообщение `Количество метров не может быть отрицательным'`.
     - В остальных случаях начисляются очки по формуле: `«количество метров умножить на 0.5»`.
     - Метод должен возвращать points. Изначально количество очков — 0.
   
3. Нужно создать класс `TotalPoints` для многоборцев. 
   - Он наследуется сразу от двух классов — `PointsForPlace` и `PointsForMeters` и реализует все их методы. Также он должен содержать:
        - метод `get_total_points()`, который принимает как аргументы `meters` и `place`;
        - переменную `total`, которая суммирует значения методов `get_points_for_place()` и `get_points_for_meters()`.
        - Метод возвращает переменную `total`.
      ❗ Подумай, какие методы в этом задании могут быть статическими. Если метод можно сделать статическим — делай.
```python
class PointsForPlace:
          ...

class PointsForMeters:
    ...

class TotalPoints(PointsForPlace, PointsForMeters):
    ...

points_for_place = PointsForPlace()
print(points_for_place.get_points_for_place(10))

points_for_meters = PointsForMeters()
print(points_for_meters.get_points_for_meters(10))

total_points = TotalPoints()
print(total_points.get_points_for_place(10))
print(total_points.get_points_for_meters(10))
print(total_points.get_total_points(100, 10))
```
---
## Задание 4
Нужно написать класс `EmployeeSalary`. Он рассчитывает почасовую заработную плату сотрудников за неделю.
1. С помощью переменной `hourly_payment` установи почасовой уровень оплаты, равный `400`.
2. Проинициализируй атрибуты `name`, `hours`, `rest_days`, `email` через конструктор.
3. Добавь метод класса `get_hours()`. Если значение hours неизвестно, метод рассчитывает часы, исходя из количества выходных — `rest_days`. Формула для этого случая такая: `(7 - rest_days) * 8`.
4. Добавь метод класса `get_email()`. Если значение email неизвестно, метод генерирует его так: `f"{name}@email.com".`
5. Добавь метод класса `set_hourly_payment()`. Он меняет значение переменной `hourly_payment`.
6. Добавь метод расчёта заработной платы `salary()`. Формула расчёта такая: `hours * hourly_payment`.
---
## Задание 5
Нужно создать класс, который подсчитывает результаты состязаний — `Results`. И двух его наследников — `Football` и `Hockey`. Подклассы наследуют все атрибуты, а ещё у них есть свои методы.
Напиши класс `Results`. Проинициализируй в нём атрибуты `victories`, `draws`, `losses` через конструктор.
Напиши класс `Football`, который наследуется от класса `Results`. Его методы:
- `number_of_wins()`, который должен возвращать запись вида `Футбольных побед: 1`. Количество побед должно браться из переменной `victories`.
- `number_of_draws()`, который должен возвращать запись вида `Футбольных ничьих: 1`. Количество ничьих должно браться из переменной `draws`.
- `number_of_losses()`, который должен возвращать запись вида `Футбольных поражений: 1`. Количество поражений возьми из переменной `losses`.
- `total_points()`, который должен возвращать запись вида `Общее количество очков: 5`. Количество очков рассчитай формуле: `3*количество побед + количество ничьих`.

Напиши класс `Hockey`, который наследуется от класса `Results`. Его методы:
- `number_of_wins()`, который должен возвращать запись вида `Хоккейных побед: 1`. Количество побед метод берёт из переменной `victories`.
- `number_of_draws()`, который должен возвращать запись вида `Хоккейных ничьих: 1`. Количество ничьих метод берёт из переменной `draws`.
`number_of_losses()`, который должен возвращать запись вида `Хоккейных поражений: 1`. Количество поражений должно браться из переменной `losses`. 
- `total_points()`, который должен возвращать запись вида `Общее количество очков: 5`. Количество очков рассчитывается по формуле: `2*количество побед + количество ничьих`.


- Создай объекты `football_team` и `hockey_team` классов `Football` и `Hockey` соответственно. 
- В качестве параметров передай (2, 2, 2). 
- Нужны вызовы всех методы для объектов `football_team` и `hockey_team`. Нужно использовать цикл for. Названия методов при этом не должны повторяться для обоих объектов.
    
